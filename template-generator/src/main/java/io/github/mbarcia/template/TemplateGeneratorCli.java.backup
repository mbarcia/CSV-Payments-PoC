/*
 * Copyright (c) 2023-2025 Mariano Barcia
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.github.mbarcia.template;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Scanner;
import java.util.concurrent.Callable;
import picocli.CommandLine;
import picocli.CommandLine.Command;
import picocli.CommandLine.Option;

@Command(name = "template-generator", mixinStandardHelpOptions = true, version = "1.0.0", description = "Pipeline Template Generator - Creates a new pipeline application from a template")
public class TemplateGeneratorCli implements Callable<Integer> {

    @Option(names = {"-o", "--output"}, description = "Output directory for generated application")
    private String outputDir = "./generated-app";
    
    @Option(names = {"-c", "--config"}, description = "Configuration file (YAML) to load pipeline specifications from")
    private String configFile;
    
    @Option(names = {"-g", "--generate-config"}, description = "Generate a sample configuration file instead of generating an application")
    private boolean generateConfig = false;

    @Override
    public Integer call() throws Exception {
        if (generateConfig) {
            // Generate a sample configuration file
            generateSampleConfig();
            return 0;
        }
        
        List<Map<String, Object>> steps;
        String appName;
        String basePackage;
        
        if (configFile != null && !configFile.isEmpty()) {
            // Load configuration from file
            Path configPath = Paths.get(configFile);
            if (!Files.exists(configPath)) {
                System.err.println("Configuration file does not exist: " + configFile);
                return 1;
            }
            
            Map<String, Object> config = loadConfigFromFile(configPath);
            appName = (String) config.get("appName");
            basePackage = (String) config.get("basePackage");
            List<Map<String, Object>> rawSteps = (List<Map<String, Object>>) config.get("steps");
            
            // Process steps to add missing properties that are normally added by interactive mode
            steps = new ArrayList<>();
            for (int i = 0; i < rawSteps.size(); i++) {
                Map<String, Object> rawStep = rawSteps.get(i);
                Map<String, Object> processedStep = new HashMap<>(rawStep);
                
                // Add missing properties
                String stepName = (String) rawStep.get("name");
                processedStep.put("serviceName", stepName.replaceAll("[^a-zA-Z0-9]", "-").toLowerCase() + "-svc");
                processedStep.put("serviceNameCamel", toCamelCase(stepName.replaceAll("[^a-zA-Z0-9]", " ")));
                processedStep.put("inputTypeSimpleName", ((String)rawStep.get("inputTypeName")).replaceAll(".*\.", ""));
                processedStep.put("outputTypeSimpleName", ((String)rawStep.get("outputTypeName")).replaceAll(".*\.", ""));
                processedStep.put("order", i + 1);
                processedStep.put("grpcClientName", stepName.replaceAll("[^a-zA-Z0-9]", "") + "Svc");
                
                // Handle stepType based on cardinality
                String cardinality = (String) rawStep.get("cardinality");
                String stepType = getStepTypeForCardinality(cardinality);
                processedStep.put("stepType", stepType);
                
                steps.add(processedStep);
            }
        } else {
            // Collect via interactive prompts
            Scanner scanner = new Scanner(System.in);
            
            System.out.println("Welcome to the Pipeline Template Generator!");
            System.out.println("==========================================");
            
            // Collect basic application info
            System.out.print("Enter the name of your application: ");
            appName = scanner.nextLine().trim();
            
            System.out.print("Enter the base package name (e.g., io.github.mbarcia): ");
            basePackage = scanner.nextLine().trim();
            
            // Create the application structure first
            Path outputPath = Paths.get(outputDir).toAbsolutePath();
            Files.createDirectories(outputPath);
            
            // Collect step information
            steps = collectSteps(scanner);
            
            // Generate a YAML config file as an intermediate step
            generateIntermediateConfig(appName, basePackage, steps);
        }
        
        // Create the application structure (in case it wasn't created during interactive mode)
        Path outputPath = Paths.get(outputDir).toAbsolutePath();
        Files.createDirectories(outputPath);
        
        // Create the template engine and generate all components
        MustacheTemplateEngine engine = new MustacheTemplateEngine();
        engine.generateApplication(appName, basePackage, steps, outputPath);
        
        System.out.println("\
Application generated successfully in: " + outputDir);
        System.out.println("Run 'cd " + outputDir + " && ./mvnw clean compile' to verify the generated application.");
        
        return 0;
    }

    
    @SuppressWarnings("unchecked")
    private Map<String, Object> loadConfigFromFile(Path configPath) throws IOException {
        ObjectMapper mapper = new ObjectMapper(new YAMLFactory());
        Map<String, Object> config = mapper.readValue(configPath.toFile(), Map.class);
        return config;
    }
    
    private List<Map<String, Object>> collectSteps(Scanner scanner) {
        List<Map<String, Object>> steps = new ArrayList<>();
        int stepNumber = 1;
        
        while (true) {
            System.out.println("
Step " + stepNumber + ":");
            System.out.print("Enter step name (or press Enter to finish): ");
            String stepName = scanner.nextLine().trim();
            
            if (stepName.isEmpty()) {
                break;
            }
            
            System.out.println("Select cardinality for step '" + stepName + "':");
            System.out.println("1) 1-1 (One-to-One)");
            System.out.println("2) Expansion (1-Many)");
            System.out.println("3) Reduction (Many-1)");
            System.out.println("4) Side-effect-only 1-1");
            
            System.out.print("Enter choice (1-4): ");
            String cardinalityChoice = scanner.nextLine().trim();
            
            String cardinality = "";
            String stepType = "";
            switch (cardinalityChoice) {
                case "1": 
                    cardinality = "ONE_TO_ONE"; 
                    stepType = "StepOneToOne";
                    break;
                case "2": 
                    cardinality = "EXPANSION"; 
                    stepType = "StepOneToMany";
                    break;
                case "3": 
                    cardinality = "REDUCTION"; 
                    stepType = "StepManyToOne";
                    break;
                case "4": 
                    cardinality = "SIDE_EFFECT"; 
                    stepType = "StepOneToOne";
                    break;
                default: 
                    System.out.println("Invalid choice, defaulting to 1-1");
                    cardinality = "ONE_TO_ONE";
                    stepType = "StepOneToOne";
                    break;
            }
            
            System.out.print("Enter input type name (plural if reduction): ");
            String inputTypeName = scanner.nextLine().trim();
            
            // Collect input fields
            List<Map<String, String>> inputFields = collectFields(scanner, "input");
            
            System.out.print("Enter output type name (plural if expansion): ");
            String outputTypeName = scanner.nextLine().trim();
            
            // Collect output fields
            List<Map<String, String>> outputFields = collectFields(scanner, "output");
            
            // Create step definition
            Map<String, Object> step = new HashMap<>();
            step.put("name", stepName);
            step.put("serviceName", stepName.replaceAll("[^a-zA-Z0-9]", "-").toLowerCase() + "-svc");
            step.put("serviceNameCamel", toCamelCase(stepName.replaceAll("[^a-zA-Z0-9]", " ")));
            step.put("cardinality", cardinality);
            step.put("stepType", stepType);
            step.put("inputTypeName", inputTypeName);
            step.put("inputTypeSimpleName", inputTypeName.replaceAll(".*\.", ""));
            step.put("inputFields", inputFields);
            step.put("outputTypeName", outputTypeName);
            step.put("outputTypeSimpleName", outputTypeName.replaceAll(".*\.", ""));
            step.put("outputFields", outputFields);
            step.put("order", stepNumber);
            step.put("grpcClientName", stepName.replaceAll("[^a-zA-Z0-9]", "") + "Svc");
            
            steps.add(step);
            stepNumber++;
        }
        
        return steps;
    }
    
    private void generateIntermediateConfig(String appName, String basePackage, List<Map<String, Object>> steps) throws IOException {
        Map<String, Object> config = new HashMap<>();
        config.put("appName", appName);
        config.put("basePackage", basePackage);
        config.put("steps", steps);
        
        // Convert to YAML
        ObjectMapper mapper = new ObjectMapper(new YAMLFactory());
        String yaml = mapper.writeValueAsString(config);
        
        Path outputPath = Paths.get(outputDir).toAbsolutePath();
        Files.createDirectories(outputPath);
        
        Path configPath = outputPath.resolve("pipeline-config.yaml");
        Files.write(configPath, yaml.getBytes());
        
        System.out.println("Intermediate configuration saved to: " + configPath);
    }
    
    private void generateSampleConfig() throws IOException {
        Map<String, Object> config = new HashMap<>();
        config.put("appName", "Sample Pipeline App");
        config.put("basePackage", "com.example.sample");
        
        List<Map<String, Object>> steps = new ArrayList<>();
        
        // Sample step 1: Process Customer
        Map<String, Object> step1 = new HashMap<>();
        step1.put("name", "Process Customer");
        step1.put("serviceName", "process-customer-svc");
        step1.put("serviceNameCamel", "processCustomer");
        step1.put("cardinality", "ONE_TO_ONE");
        step1.put("stepType", "StepOneToOne");
        step1.put("inputTypeName", "CustomerInput");
        step1.put("inputTypeSimpleName", "CustomerInput");
        
        List<Map<String, String>> inputFields1 = new ArrayList<>();
        Map<String, String> inputField1 = new HashMap<>();
        inputField1.put("name", "id");
        inputField1.put("type", "UUID");
        inputField1.put("protoType", "string");
        inputFields1.add(inputField1);
        
        Map<String, String> inputField2 = new HashMap<>();
        inputField2.put("name", "name");
        inputField2.put("type", "String");
        inputField2.put("protoType", "string");
        inputFields1.add(inputField2);
        
        Map<String, String> inputField3 = new HashMap<>();
        inputField3.put("name", "email");
        inputField3.put("type", "String");
        inputField3.put("protoType", "string");
        inputFields1.add(inputField3);
        
        step1.put("inputFields", inputFields1);
        step1.put("outputTypeName", "CustomerOutput");
        step1.put("outputTypeSimpleName", "CustomerOutput");
        
        List<Map<String, String>> outputFields1 = new ArrayList<>();
        Map<String, String> outputField1 = new HashMap<>();
        outputField1.put("name", "id");
        outputField1.put("type", "UUID");
        outputField1.put("protoType", "string");
        outputFields1.add(outputField1);
        
        Map<String, String> outputField2 = new HashMap<>();
        outputField2.put("name", "name");
        outputField2.put("type", "String");
        outputField2.put("protoType", "string");
        outputFields1.add(outputField2);
        
        Map<String, String> outputField3 = new HashMap<>();
        outputField3.put("name", "status");
        outputField3.put("type", "String");
        outputField3.put("protoType", "string");
        outputFields1.add(outputField3);
        
        Map<String, String> outputField4 = new HashMap<>();
        outputField4.put("name", "processedAt");
        outputField4.put("type", "String");
        outputField4.put("protoType", "string");
        outputFields1.add(outputField4);
        
        step1.put("outputFields", outputFields1);
        step1.put("order", 1);
        step1.put("grpcClientName", "ProcessCustomerSvc");
        steps.add(step1);
        
        // Sample step 2: Validate Order
        Map<String, Object> step2 = new HashMap<>();
        step2.put("name", "Validate Order");
        step2.put("serviceName", "validate-order-svc");
        step2.put("serviceNameCamel", "validateOrder");
        step2.put("cardinality", "EXPANSION");
        step2.put("stepType", "StepOneToMany");
        step2.put("inputTypeName", "OrderInput");
        step2.put("inputTypeSimpleName", "OrderInput");
        
        List<Map<String, String>> inputFields2 = new ArrayList<>();
        Map<String, String> inputField4 = new HashMap<>();
        inputField4.put("name", "orderId");
        inputField4.put("type", "String");
        inputField4.put("protoType", "string");
        inputFields2.add(inputField4);
        
        Map<String, String> inputField5 = new HashMap<>();
        inputField5.put("name", "items");
        inputField5.put("type", "String");
        inputField5.put("protoType", "string");
        inputFields2.add(inputField5);
        
        step2.put("inputFields", inputFields2);
        step2.put("outputTypeName", "OrderItem");
        step2.put("outputTypeSimpleName", "OrderItem");
        
        List<Map<String, String>> outputFields2 = new ArrayList<>();
        Map<String, String> outputField5 = new HashMap<>();
        outputField5.put("name", "itemId");
        outputField5.put("type", "String");
        outputField5.put("protoType", "string");
        outputFields2.add(outputField5);
        
        Map<String, String> outputField6 = new HashMap<>();
        outputField6.put("name", "valid");
        outputField6.put("type", "Boolean");
        outputField6.put("protoType", "bool");
        outputFields2.add(outputField6);
        
        step2.put("outputFields", outputFields2);
        step2.put("order", 2);
        step2.put("grpcClientName", "ValidateOrderSvc");
        steps.add(step2);
        
        config.put("steps", steps);
        
        // Convert to YAML
        ObjectMapper mapper = new ObjectMapper(new YAMLFactory());
        String yaml = mapper.writeValueAsString(config);
        
        Path configPath = Paths.get("./sample-pipeline-config.yaml").toAbsolutePath();
        Files.write(configPath, yaml.getBytes());
        
        System.out.println("Sample configuration file generated at: " + configPath);
        System.out.println("Use this file with the -c option to generate an application from configuration:");
        System.out.println("  java -jar template-generator-1.0.0.jar -c sample-pipeline-config.yaml -o /path/to/output");
    }
    
    private List<Map<String, String>> collectFields(Scanner scanner, String type) {
        List<Map<String, String>> fields = new ArrayList<>();
        
        System.out.println("Define fields for " + type + " type (enter empty field name to continue):");
        
        while (true) {
            System.out.print("Field name (or Enter to finish " + type + " fields): ");
            String fieldName = scanner.nextLine().trim();
            
            if (fieldName.isEmpty()) {
                break;
            }
            
            System.out.println("Available types: string, int, long, double, boolean, uuid, bigdecimal, currency, path");
            System.out.print("Field type for '" + fieldName + "': ");
            String fieldType = scanner.nextLine().trim();
            
            if (fieldType.isEmpty()) {
                fieldType = "string"; // default to string
            }
            
            Map<String, String> field = new HashMap<>();
            field.put("name", fieldName);
            field.put("type", mapFieldType(fieldType));
            field.put("protoType", mapToProtoType(fieldType));
            fields.add(field);
        }
        
        return fields;
    }
    
    private String mapFieldType(String inputType) {
        switch (inputType.toLowerCase()) {
            case "string": return "String";
            case "int": return "Integer";
            case "long": return "Long";
            case "double": return "Double";
            case "boolean": return "Boolean";
            case "uuid": return "UUID";
            case "bigdecimal": return "BigDecimal";
            case "currency": return "Currency";
            case "path": return "Path";
            default: return "String"; // default to String
        }
    }
    
    private String mapToProtoType(String inputType) {
        switch (inputType.toLowerCase()) {
            case "string": return "string";
            case "int": return "int32";
            case "long": return "int64";
            case "double": return "double";
            case "boolean": return "bool";
            case "uuid": return "string";
            case "bigdecimal": return "string";
            case "currency": return "string";
            case "path": return "string";
            default: return "string"; // default to string
        }
    }
    
    private String toCamelCase(String input) {
        String[] parts = input.trim().split("\s+");
        StringBuilder result = new StringBuilder();
        
        for (int i = 0; i < parts.length; i++) {
            String part = parts[i];
            if (part.length() > 0) {
                if (i == 0) {
                    result.append(Character.toLowerCase(part.charAt(0)));
                } else {
                    result.append(Character.toUpperCase(part.charAt(0)));
                }
                result.append(part.substring(1).toLowerCase());
            }
        }
        
        return result.toString();
    }
    
    private String getStepTypeForCardinality(String cardinality) {
        if (cardinality == null) {
            return "StepOneToOne"; // default
        }
        
        switch (cardinality) {
            case "EXPANSION":
                return "StepOneToMany";
            case "REDUCTION":
                return "StepManyToOne";
            case "SIDE_EFFECT":
            case "ONE_TO_ONE":
            default:
                return "StepOneToOne";
        }
    }
    
    public static void main(String[] args) {
        int exitCode = new CommandLine(new TemplateGeneratorCli()).execute(args);
        System.exit(exitCode);
    }
}